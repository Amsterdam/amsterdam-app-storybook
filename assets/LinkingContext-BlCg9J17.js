import{e as O,q as I}from"./usePiwikTrackCustomEventFromProps-C531Phul.js";import{r as z}from"./index-B-xgG2PE.js";function A(e){var t,n;let r=e;for(;((i=r)===null||i===void 0?void 0:i.routes[r.index??0].state)!=null;){var i;r=r.routes[r.index??0].state}return(t=r)===null||t===void 0?void 0:t.routes[((n=r)===null||n===void 0?void 0:n.index)??0]}function D(e,t){var n;const r=t?$(t):{},i=e.index!=null?e.routes.slice(0,e.index+1):e.routes;if(i.length===0)return;if(!(i.length===1&&i[0].key===void 0||i.length===2&&i[0].key===void 0&&i[0].name===(r==null?void 0:r.initialRouteName)&&i[1].key===void 0))return{type:"RESET",payload:e};const s=e.routes[e.index??e.routes.length-1];let u=s==null?void 0:s.state,l=r==null||(n=r.screens)===null||n===void 0?void 0:n[s==null?void 0:s.name],d={...s.params},p=s?{name:s.name,path:s.path,params:d}:void 0;for(;u;){var a,o,f;if(u.routes.length===0)return;const c=u.index!=null?u.routes.slice(0,u.index+1):u.routes,m=c[c.length-1];if(Object.assign(d,{initial:void 0,screen:void 0,params:void 0,state:void 0}),c.length===1&&c[0].key===void 0)d.initial=!0,d.screen=m.name;else if(c.length===2&&c[0].key===void 0&&c[0].name===((a=l)===null||a===void 0?void 0:a.initialRouteName)&&c[1].key===void 0)d.initial=!1,d.screen=m.name;else{d.state=u;break}m.state?(d.params={...m.params},d=d.params):(d.path=m.path,d.params=m.params),u=m.state,l=(o=l)===null||o===void 0||(f=o.screens)===null||f===void 0?void 0:f[m.name]}if(p)return{type:"NAVIGATE",payload:p}}const $=e=>typeof e=="object"&&e!=null?{initialRouteName:e.initialRouteName,screens:e.screens!=null?F(e.screens):void 0}:{},F=e=>Object.entries(e).reduce((t,n)=>{let[r,i]=n;return t[r]=$(i),t},{}),R=e=>e.map(t=>`- ${t}`).join(`
`);function C(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;const n=["initialRouteName","screens"];t||n.push("path","exact","stringify","parse");const r=Object.keys(e).filter(i=>!n.includes(i));if(r.length)throw new Error(`Found invalid properties in the configuration:
${R(r)}

Did you forget to specify them under a 'screens' property?

You can only specify the following properties:
${R(n)}

See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);e.screens&&Object.entries(e.screens).forEach(i=>{let[s,u]=i;typeof u!="string"&&C(u,!1)})}function G(e,t){t&&C(t);let n=[];t!=null&&t.initialRouteName&&n.push({initialRouteName:t.initialRouteName,parentScreens:[]});const r=t==null?void 0:t.screens;let i=e.replace(/\/+/g,"/").replace(/^\//,"").replace(/\?.*$/,"");if(i=i.endsWith("/")?i:`${i}/`,r===void 0){const a=i.split("/").filter(Boolean).map(o=>({name:decodeURIComponent(o)}));return a.length?j(e,a,n):void 0}const s=[].concat(...Object.keys(r).map(a=>E(a,r,[],n,[]))).sort((a,o)=>{if(a.pattern===o.pattern)return o.routeNames.join(">").localeCompare(a.routeNames.join(">"));if(a.pattern.startsWith(o.pattern))return-1;if(o.pattern.startsWith(a.pattern))return 1;const f=a.pattern.split("/"),c=o.pattern.split("/");for(let m=0;m<Math.max(f.length,c.length);m++){if(f[m]==null)return 1;if(c[m]==null)return-1;const h=f[m]==="*"||f[m].startsWith(":"),g=c[m]==="*"||c[m].startsWith(":");if(!(h&&g)){if(h)return 1;if(g)return-1}}return c.length-f.length});if(s.reduce((a,o)=>{if(a[o.pattern]){const f=a[o.pattern].routeNames,c=o.routeNames;if(!(f.length>c.length?c.every((h,g)=>f[g]===h):f.every((h,g)=>c[g]===h)))throw new Error(`Found conflicting screens with the same pattern. The pattern '${o.pattern}' resolves to both '${f.join(" > ")}' and '${c.join(" > ")}'. Patterns must be unique and cannot resolve to more than one screen.`)}return Object.assign(a,{[o.pattern]:o})},{}),i==="/"){const a=s.find(o=>o.path===""&&o.routeNames.every(f=>{var c;return!((c=s.find(m=>m.screen===f))!==null&&c!==void 0&&c.path)}));return a?j(e,a.routeNames.map(o=>({name:o})),n,s):void 0}let u,l;const{routes:d,remainingPath:p}=L(i,s.map(a=>({...a,regex:a.regex?new RegExp(a.regex.source+"$"):void 0})));if(d!==void 0&&(l=j(e,d,n,s),i=p,u=l),!(l==null||u==null))return u}const b=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return[].concat(...t.map(r=>r.split("/"))).filter(Boolean).join("/")},L=(e,t)=>{let n,r=e;for(const s of t){if(!s.regex)continue;const u=r.match(s.regex);if(u){var i;const d=((i=s.pattern)===null||i===void 0?void 0:i.split("/").reduce((p,a,o)=>{if(!a.startsWith(":"))return p;p.pos+=1;const f=decodeURIComponent(u[(p.pos+1)*2].replace(/\/$/,""));return Object.assign(p.matchedParams,{[a]:Object.assign(p.matchedParams[a]||{},{[o]:f})}),p},{pos:-1,matchedParams:{}})).matchedParams||{};n=s.routeNames.map(p=>{var a;const o=t.find(h=>h.screen===p&&s.pattern.startsWith(h.pattern)),f=o==null?void 0:o.path.split("/").filter(Boolean).join("/"),c=o==null||(a=o.pattern.replace(new RegExp(`${O(f)}$`),""))===null||a===void 0?void 0:a.split("/").length,m=f==null?void 0:f.split("/").reduce((h,g,S)=>{var v;if(!g.startsWith(":"))return h;const W=c?c-1:0,y=(v=d[g])===null||v===void 0?void 0:v[S+W];if(y){var x;const N=g.replace(/^:/,"").replace(/\?$/,"");h[N]=o!=null&&(x=o.parse)!==null&&x!==void 0&&x[N]?o.parse[N](y):y}return h},{});return m&&Object.keys(m).length?{name:p,params:m}:{name:p}}),r=r.replace(u[1],"");break}}return{routes:n,remainingPath:r}},E=function(e,t){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:[],r=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;const u=[];n.push(e),i.push(e);const l=t[e];if(typeof l=="string"){const d=s?b(s,l):l;u.push(P(e,n,d,l))}else if(typeof l=="object"){let d;if(typeof l.path=="string"){if(l.exact&&l.path===void 0)throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");d=l.exact!==!0?b(s||"",l.path||""):l.path||"",u.push(P(e,n,d,l.path,l.parse))}l.screens&&(l.initialRouteName&&r.push({initialRouteName:l.initialRouteName,parentScreens:i}),Object.keys(l.screens).forEach(p=>{const a=E(p,l.screens,n,r,[...i],d??s);u.push(...a)}))}return n.pop(),u},P=(e,t,n,r,i)=>{n=n.split("/").filter(Boolean).join("/");const s=n?new RegExp(`^(${n.split("/").map(u=>u.startsWith(":")?`(([^/]+\\/)${u.endsWith("?")?"?":""})`:`${u==="*"?".*":O(u)}\\/`).join("")})`):void 0;return{screen:e,regex:s,pattern:n,path:r,routeNames:[...t],parse:i}},q=(e,t)=>{for(const n of t)if(e===n.routeNames[n.routeNames.length-1])return n.parse},w=(e,t,n)=>{for(const r of n)if(t.length===r.parentScreens.length){let i=!0;for(let s=0;s<t.length;s++)if(t[s].localeCompare(r.parentScreens[s])!==0){i=!1;break}if(i)return e!==r.initialRouteName?r.initialRouteName:void 0}},k=(e,t,n)=>n?e?{index:1,routes:[{name:e},t]}:{routes:[t]}:e?{index:1,routes:[{name:e},{...t,state:{routes:[]}}]}:{routes:[{...t,state:{routes:[]}}]},j=(e,t,n,r)=>{let i,s=t.shift();const u=[];let l=w(s.name,u,n);if(u.push(s.name),i=k(l,s,t.length===0),t.length>0){let p=i;for(;s=t.shift();){l=w(s.name,u,n);const a=p.index||p.routes.length-1;p.routes[a].state=k(l,s,t.length===0),t.length>0&&(p=p.routes[a].state),u.push(s.name)}}s=A(i),s.path=e;const d=B(e,r?q(s.name,r):void 0);return d&&(s.params={...s.params,...d}),i},B=(e,t)=>{const n=e.split("?")[1],r=I.parse(n);return t&&Object.keys(r).forEach(i=>{Object.hasOwnProperty.call(t,i)&&typeof r[i]=="string"&&(r[i]=t[i](r[i]))}),Object.keys(r).length?r:void 0},T=z.createContext({options:void 0});T.displayName="LinkingContext";export{T as L,D as a,A as f,G as g,C as v};
