var ft=Object.defineProperty;var ht=(t,n,e)=>n in t?ft(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var b=(t,n,e)=>ht(t,typeof n!="symbol"?n+"":n,e);import{d as gt,g as dt,C as M,u as st,i as bt,m as wt,b as kt,s as mt,c as pt,e as $,f as At,R as V,h as H,j as z,k as Et,l as yt,r as G,p as Mt,n as Ct,o as Vt,q as xt,t as Lt,v as It}from"./Animated-Db2DkEap.js";import{r as C}from"./index-C6mWTJJr.js";const te=function(t,n=2,e=!1,o,s){"worklet";return gt(t,()=>{"worklet";const r=typeof t=="function"?t():t;function i(c,f){const h=r.onFrame(r,f);if(c.current=r.current,h){if(c.reps+=1,r.callback&&r.callback(!0,c.current),c.reduceMotion||n>0&&c.reps>=n)return!0;const u=e?r.current:c.startValue;return e&&(r.toValue=c.startValue,c.startValue=u),r.onStart(r,u,f,r.previousAnimation),!1}return!1}const l=c=>{o&&o(c),!c&&r.callback&&r.callback(!1)};function a(c,f,h,u){c.startValue=f,c.reps=0,r.reduceMotion===void 0&&(r.reduceMotion=c.reduceMotion),c.reduceMotion&&e&&(n<=0||n%2===0)?(c.current=c.startValue,c.onFrame=()=>!0):r.onStart(r,f,h,u)}return{isHigherOrder:!0,onFrame:i,onStart:a,reps:0,current:r.current,callback:l,startValue:0,reduceMotion:dt(s)}})},S=class S extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originX:e(r,o(a.targetOriginX,s))},initialValues:{originX:a.targetOriginX+a.windowWidth,...l},callback:i}}})}static createInstance(){return new S}};b(S,"presetName","SlideInRight");let K=S;const D=class D extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originX:e(r,o(a.targetOriginX,s))},initialValues:{originX:a.targetOriginX-a.windowWidth,...l},callback:i}}})}static createInstance(){return new D}};b(D,"presetName","SlideInLeft");let Q=D;const F=class F extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originX:e(r,o(Math.max(a.currentOriginX+a.windowWidth,a.windowWidth),s))},initialValues:{originX:a.currentOriginX,...l},callback:i}}})}static createInstance(){return new F}};b(F,"presetName","SlideOutRight");let Z=F;const T=class T extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originX:e(r,o(Math.min(a.currentOriginX-a.windowWidth,-a.windowWidth),s))},initialValues:{originX:a.currentOriginX,...l},callback:i}}})}static createInstance(){return new T}};b(T,"presetName","SlideOutLeft");let tt=T;const X=class X extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originY:e(r,o(a.targetOriginY,s))},initialValues:{originY:-a.windowHeight,...l},callback:i}}})}static createInstance(){return new X}};b(X,"presetName","SlideInUp");let et=X;const N=class N extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originY:e(r,o(a.targetOriginY,s))},initialValues:{originY:a.targetOriginY+a.windowHeight,...l},callback:i}}})}static createInstance(){return new N}};b(N,"presetName","SlideInDown");let nt=N;const Y=class Y extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originY:e(r,o(Math.min(a.currentOriginY-a.windowHeight,-a.windowHeight),s))},initialValues:{originY:a.currentOriginY,...l},callback:i}}})}static createInstance(){return new Y}};b(Y,"presetName","SlideOutUp");let rt=Y;const j=class j extends M{constructor(){super(...arguments);b(this,"build",()=>{const e=this.getDelayFunction(),[o,s]=this.getAnimationAndConfig(),r=this.getDelay(),i=this.callbackV,l=this.initialValues;return a=>{"worklet";return{animations:{originY:e(r,o(Math.max(a.currentOriginY+a.windowHeight,a.windowHeight),s))},initialValues:{originY:a.currentOriginY,...l},callback:i}}})}static createInstance(){return new j}};b(j,"presetName","SlideOutDown");let it=j;function at(t){return Object.values(t).reduce((n,e)=>n+e.__workletHash.toString(),"")}function ee(t,n){const e=Object.values(n).filter(o=>o!==void 0);return t?t.push(at(e)):t=e.map(o=>({workletHash:o.__workletHash,closure:o.__closure})),t}function ne(t,n){function e(r,i){return r===i&&(r!==0||1/r===1/i)||Number.isNaN(r)&&Number.isNaN(i)}const o=typeof Object.is=="function"?Object.is:e;function s(r,i){if(!r||!i||i.length!==r.length)return!1;for(let l=0;l<i.length;++l)if(!o(r[l],i[l]))return!1;return!0}return s(t,n)}function x(t){"worklet";return Array.isArray(t)?t.some(x):typeof t=="object"&&t!==null?t.onFrame!==void 0?!0:Object.values(t).some(x):!1}function lt(t,n){"worklet";const e=Object.keys(t),o=Object.keys(n);if(e.length!==o.length)return!1;for(let s=0;s<e.length;s++)if(t[e[s]]!==n[e[s]])return!1;return!0}function Ot(t){"worklet";const n=[];for(const e of t.split(/,(?![^()]*\))/).map(o=>o.trim()).filter(o=>o!=="")){const o={offsetX:0,offsetY:0};let s=null,r=null,i=!1,l=0;const a=e.split(/\s+(?![^(]*\))/);for(const c of a){if(c==="inset"){if(o.inset!=null)return[];s!=null&&(i=!0),o.inset=!0;continue}switch(l){case 0:s=c,l++;break;case 1:if(i)return[];r=c,l++;break;case 2:if(i)return[];o.blurRadius=c,l++;break;case 3:if(i)return[];o.spreadDistance=c,l++;break;case 4:if(i)return[];o.color=c,l++;break;default:return[]}}if(s===null||r===null)return[];o.offsetX=s,o.offsetY=r,n.push(o)}return n}function L(t){"worklet";const e=/([+-]?\d*(\.\d+)?)([\w\W]+)?/g.exec(t);return!e||Number.isNaN(e[1])||e[3]!=null&&e[3]!=="px"?null:Number(e[1])}function St(t){"worklet";const n=[],e=t.boxShadow;if(e==="")return n;const o=Ot(e.replace(/\n/g," "));for(const s of o){const r={offsetX:0,offsetY:0};let i;for(const l in s)switch(l){case"offsetX":if(i=typeof s.offsetX=="string"?L(s.offsetX):s.offsetX,i===null)return[];r.offsetX=i;break;case"offsetY":if(i=typeof s.offsetY=="string"?L(s.offsetY):s.offsetY,i===null)return[];r.offsetY=i;break;case"spreadDistance":if(i=typeof s.spreadDistance=="string"?L(s.spreadDistance):s.spreadDistance,i===null)return[];r.spreadDistance=i;break;case"blurRadius":if(i=typeof s.blurRadius=="string"?L(s.blurRadius):s.blurRadius,i===null||i<0)return[];r.blurRadius=i;break;case"color":r.color=s.color;break;case"inset":r.inset=s.inset}n.push(r)}t.boxShadow=n}const Dt=At();function I(t,n,e,o){"worklet";if(Array.isArray(n)&&n.forEach((s,r)=>{I(t,s,e&&e[r],o&&o[r])}),typeof n=="object"&&n.onFrame){const s=n;let r=s.current;o!=null&&(typeof o=="object"?o.value!==void 0?r=o.value:o.onFrame!==void 0&&((e==null?void 0:e.current)!==void 0?r=e.current:(o==null?void 0:o.current)!==void 0&&(r=o.current)):r=o),s.callStart=i=>{s.onStart(s,r,i,e)},s.callStart(t),s.callStart=null}else typeof n=="object"&&Object.keys(n).forEach(s=>I(t,n[s],e&&e[s],o&&o[s]))}function O(t,n,e,o,s,r){"worklet";if(!s.value)return!0;if(Array.isArray(t)){o[e]=[];let i=!0;return r=e==="boxShadow",t.forEach((l,a)=>{O(l,n,a,o[e],s,r)||(i=!1)}),i}else if(typeof t=="object"&&t.onFrame){let i=!0;return t.finished||(t.callStart&&(t.callStart(n),t.callStart=null),i=t.onFrame(t,n),t.timestamp=n,i&&(t.finished=!0,t.callback&&t.callback(!0))),r?o[e]={...t.current}:o[e]=t.current,i}else if(typeof t=="object"){o[e]={};let i=!0;return Object.keys(t).forEach(l=>{O(t[l],n,l,o[e],s,r)||(i=!1)}),i}else return o[e]=t,!0}function Ft(t,n,e,o,s=!1){"worklet";const r=e.animations??{},i=n()??{},l=e.last,a={};let c=!1,f,h=!1;typeof i.boxShadow=="string"&&St(i);for(const u in i){const g=i[u];x(g)?(f=global.__frameTimestamp||global._getAnimationTimestamp(),I(f,g,r[u],l[u]),r[u]=g,c=!0):(h=!0,a[u]=g,delete r[u])}if(c){const u=g=>{const{animations:E,last:k,isAnimationCancelled:y}=e;if(y){e.isAnimationRunning=!1;return}const m={};let p=!0;for(const A in E)O(E[A],g,A,m,o)?(Array.isArray(m[A])?m[A].forEach(q=>{for(const J in q)k[A][J]=q[J]}):k[A]=m[A],delete E[A]):p=!1;m&&H(t,m),p?e.isAnimationRunning=!1:requestAnimationFrame(u)};e.animations=r,e.isAnimationRunning||(e.isAnimationCancelled=!1,e.isAnimationRunning=!0,u(f)),h&&H(t,a)}else e.isAnimationCancelled=!0,e.animations=[],lt(l,i)||H(t,i,s);e.last=i}function Tt(t,n,e,o,s,r){"worklet";const i=e.animations??{},l=n()??{},a=e.last;let c=!1,f;Object.keys(i).forEach(u=>{const g=l[u];x(g)||delete i[u]}),Object.keys(l).forEach(u=>{const g=l[u];x(g)&&(f=global.__frameTimestamp||global._getAnimationTimestamp(),I(f,g,i[u],a[u]),i[u]=g,c=!0)});function h(u){const{animations:g,last:E,isAnimationCancelled:k}=e;if(k){e.isAnimationRunning=!1;return}const y={};let m=!0;Object.keys(g).forEach(p=>{O(g[p],u,p,y,o)?(E[p]=y[p],delete g[p]):m=!1}),Object.keys(y).length&&z(t,y,s,r),m?e.isAnimationRunning=!1:requestAnimationFrame(h)}c?(e.animations=i,e.isAnimationRunning||(e.isAnimationCancelled=!1,e.isAnimationRunning=!0,h(f))):(e.isAnimationCancelled=!0,e.animations=[]),e.last=l,lt(a,l)||z(t,l,s,r)}function U(t,n){if(Array.isArray(t))for(const e of t)U(e,n);else if(typeof t=="object"&&t!==null&&t.value===void 0)for(const e of Object.keys(t))U(t[e],e);else if(n!==void 0&&typeof t=="object"&&t!==null&&t.value!==void 0)throw new V(`Invalid value passed to \`${n}\`, maybe you forgot to use \`.value\`?`)}function re(t,n,e,o=!1){const s=C.useRef(null);let r=Object.values(t.__closure??{});Dt&&!r.length&&n!=null&&n.length&&(r=n);const i=e?Array.isArray(e)?e:[e]:[],l=e?at(i):null,a=st(!0),c=C.useRef({});if(n?n.push(t.__workletHash):n=[...r,t.__workletHash],l&&n.push(l),!s.current){const k=bt(t);s.current={initial:{value:k,updater:t},remoteState:wt({last:k,animations:{},isAnimationCancelled:!1,isAnimationRunning:!1}),viewDescriptors:kt()}}const{initial:f,remoteState:h,viewDescriptors:u}=s.current,g=u.shareableViewDescriptors;n.push(g),C.useEffect(()=>{let k,y=t;e&&(y=()=>{"worklet";const p=t();return i.forEach(A=>{A(p)}),p}),$()?k=()=>{"worklet";Tt(g,t,h,a,c,i)}:k=()=>{"worklet";Ft(g,y,h,a,o)};const m=mt(k,r);return()=>{pt(m)}},n),C.useEffect(()=>(a.value=!0,()=>{a.value=!1}),[a]),U(f.value);const E=C.useRef(null);return E.current||(E.current=$()?{viewDescriptors:u,initial:f,jestAnimatedStyle:c}:{viewDescriptors:u,initial:f}),E.current}const B=(t=0)=>{"worklet";const n=Math.abs(t);return n>.0031308?(Math.sign(t)||1)*(1.055*Math.pow(n,1/2.4)-.055):t*12.92},Xt=({r:t,g:n,b:e,alpha:o})=>{"worklet";return{r:B(t),g:B(n),b:B(e),alpha:o}},v=(t=0)=>{"worklet";const n=Math.abs(t);return n<=.04045?t/12.92:(Math.sign(t)||1)*Math.pow((n+.055)/1.055,2.4)},Nt=({r:t,g:n,b:e,alpha:o})=>{"worklet";return{r:v(t),g:v(n),b:v(e),alpha:o}},ct={convert:{fromRgb:Nt,toRgb:Xt}};function Yt({r:t=0,g:n=0,b:e=0,alpha:o}){"worklet";const s=Math.cbrt(.41222147079999993*t+.5363325363*n+.0514459929*e),r=Math.cbrt(.2119034981999999*t+.6806995450999999*n+.1073969566*e),i=Math.cbrt(.08830246189999998*t+.2817188376*n+.6299787005000002*e);return{l:.2104542553*s+.793617785*r-.0040720468*i,a:1.9779984951*s-2.428592205*r+.4505937099*i,b:.0259040371*s+.7827717662*r-.808675766*i,alpha:o}}function jt(t){"worklet";const n=ct.convert.fromRgb(t),e=Yt(n);return t.r===t.b&&t.b===t.g&&(e.a=e.b=0),e}function Ht({l:t=0,a:n=0,b:e=0,alpha:o}){"worklet";const s=Math.pow(t*.9999999984505198+.39633779217376786*n+.2158037580607588*e,3),r=Math.pow(t*1.0000000088817609-.10556134232365635*n-.06385417477170591*e,3),i=Math.pow(t*1.0000000546724108-.08948418209496575*n-1.2914855378640917*e,3);return{r:4.076741661347994*s-3.307711590408193*r+.230969928729428*i,g:-1.2684380040921763*s+2.6097574006633715*r-.3413193963102197*i,b:-.004196086541837188*s-.7034186144594493*r+1.7076147009309444*i,alpha:o}}function Bt(t){"worklet";const n=s=>Math.ceil(s*1e5)/1e5,e=Ht(t),o=ct.convert.toRgb(e);return o.r=n(o.r),o.g=n(o.g),o.b=n(o.b),o}const vt={convert:{fromRgb:jt,toRgb:Bt}},ut={oklab:vt};let d=function(t){return t.IDENTITY="identity",t.CLAMP="clamp",t.EXTEND="extend",t}({});function ot(t,n,e,o,s,r){"worklet";switch(t){case d.IDENTITY:return r;case d.CLAMP:return n*e<n*o?o:s;case d.EXTEND:default:return e}}function R(t){"worklet";return t===d.EXTEND||t===d.CLAMP||t===d.IDENTITY}function Rt(t){"worklet";const n={extrapolateLeft:d.EXTEND,extrapolateRight:d.EXTEND};if(!t)return n;if(typeof t=="string"){if(!R(t))throw new V(`Unsupported value for "interpolate" 
Supported values: ["extend", "clamp", "identity", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]
 Valid example:
        interpolate(value, [inputRange], [outputRange], "clamp")`);return n.extrapolateLeft=t,n.extrapolateRight=t,n}if(t.extrapolateLeft&&!R(t.extrapolateLeft)||t.extrapolateRight&&!R(t.extrapolateRight))throw new V(`Unsupported value for "interpolate" 
Supported values: ["extend", "clamp", "identity", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]
 Valid example:
      interpolate(value, [inputRange], [outputRange], {
        extrapolateLeft: Extrapolation.CLAMP,
        extrapolateRight: Extrapolation.IDENTITY
      }})`);return Object.assign(n,t),n}function Pt(t,n,e){"worklet";const{leftEdgeInput:o,rightEdgeInput:s,leftEdgeOutput:r,rightEdgeOutput:i}=n;if(s-o===0)return r;const l=(t-o)/(s-o),a=r+l*(i-r),c=i>=r?1:-1;return c*a<c*r?ot(e.extrapolateLeft,c,a,r,i,t):c*a>c*i?ot(e.extrapolateRight,c,a,r,i,t):a}function w(t,n,e,o){"worklet";if(n.length<2||e.length<2)throw new V("Interpolation input and output ranges should contain at least two values.");const s=Rt(o),r=n.length,i={leftEdgeInput:n[0],rightEdgeInput:n[1],leftEdgeOutput:e[0],rightEdgeOutput:e[1]};if(r>2){if(t>n[r-1])i.leftEdgeInput=n[r-2],i.rightEdgeInput=n[r-1],i.leftEdgeOutput=e[r-2],i.rightEdgeOutput=e[r-1];else for(let l=1;l<r;++l)if(t<=n[l]){i.leftEdgeInput=n[l-1],i.rightEdgeInput=n[l],i.leftEdgeOutput=e[l-1],i.rightEdgeOutput=e[l];break}}return Pt(t,i,s)}function ie(t,n,e){"worklet";return Math.min(Math.max(t,n),e)}const oe=d,Wt=(t,n,e,o)=>{"worklet";let s=0;const{useCorrectedHSVInterpolation:r=!0}=o;if(r){const c=[n[0]],f=e.h,h=[f[0]];for(let u=1;u<f.length;++u){const g=f[u]-f[u-1];f[u]>f[u-1]&&g>.5?(c.push(n[u]),c.push(n[u]+1e-5),h.push(f[u]-1),h.push(f[u])):f[u]<f[u-1]&&g<-.5?(c.push(n[u]),c.push(n[u]+1e-5),h.push(f[u]+1),h.push(f[u])):(c.push(n[u]),h.push(f[u]))}s=(w(t,c,h,d.CLAMP)+1)%1}else s=w(t,n,e.h,d.CLAMP);const i=w(t,n,e.s,d.CLAMP),l=w(t,n,e.v,d.CLAMP),a=w(t,n,e.a,d.CLAMP);return yt(s,i,l,a)},P=(t,n)=>{"worklet";return t.map(e=>Math.pow(e/255,n))},W=(t,n)=>{"worklet";return Math.round(Math.pow(t,1/n)*255)},Gt=(t,n,e,o)=>{"worklet";const{gamma:s=2.2}=o;let{r,g:i,b:l}=e;s!==1&&(r=P(r,s),i=P(i,s),l=P(l,s));const a=w(t,n,r,d.CLAMP),c=w(t,n,i,d.CLAMP),f=w(t,n,l,d.CLAMP),h=w(t,n,e.a,d.CLAMP);return s===1?G(a,c,f,h):G(W(a,s),W(c,s),W(f,s),h)},Ut=(t,n,e,o)=>{"worklet";const s=w(t,n,e.l,d.CLAMP),r=w(t,n,e.a,d.CLAMP),i=w(t,n,e.b,d.CLAMP),l=w(t,n,e.alpha,d.CLAMP),{r:a,g:c,b:f,alpha:h}=ut.oklab.convert.toRgb({l:s,a:r,b:i,alpha:l});return G(a,c,f,h)},_=(t,n)=>{"worklet";const e=[],o=[],s=[],r=[];for(let i=0;i<t.length;i++){const l=t[i],a=Mt(l);if(typeof a=="number"){const c=n({r:Ct(a),g:Vt(a),b:xt(a)});e.push(c.ch1),o.push(c.ch2),s.push(c.ch3),r.push(Lt(a))}}return{ch1:e,ch2:o,ch3:s,alpha:r}},_t=t=>{"worklet";const{ch1:n,ch2:e,ch3:o,alpha:s}=_(t,r=>({ch1:r.r,ch2:r.g,ch3:r.b}));return{r:n,g:e,b:o,a:s}},qt=t=>{"worklet";const{ch1:n,ch2:e,ch3:o,alpha:s}=_(t,r=>{const i=It(r.r,r.g,r.b);return{ch1:i.h,ch2:i.s,ch3:i.v}});return{h:n,s:e,v:o,a:s}},Jt=t=>{"worklet";const{ch1:n,ch2:e,ch3:o,alpha:s}=_(t,r=>{const i=ut.oklab.convert.fromRgb(r);return{ch1:i.l,ch2:i.a,ch3:i.b}});return{l:n,a:e,b:o,alpha:s}};function se(t,n,e,o="RGB",s={}){"worklet";if(o==="HSV")return Wt(t,n,qt(e),s);if(o==="RGB")return Gt(t,n,_t(e),s);if(o==="LAB")return Ut(t,n,Jt(e));throw new V(`Invalid color space provided: ${o}. Supported values are: ['RGB', 'HSV', 'LAB'].`)}let $t=function(t){return t[t.RGB=0]="RGB",t[t.HSV=1]="HSV",t[t.LAB=2]="LAB",t}({});function ae(t,n,e=$t.RGB,o={}){return st({inputRange:t,outputRange:n,colorSpace:e,cache:Et(null),options:o})}export{$t as C,oe as E,nt as S,ne as a,ee as b,d as c,Q as d,K as e,et as f,it as g,tt as h,Z as i,rt as j,ie as k,w as l,se as m,ae as n,re as u,te as w};
