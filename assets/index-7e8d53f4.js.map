{"version":3,"file":"index-7e8d53f4.js","sources":["../../node_modules/react-native-web/dist/modules/usePressEvents/PressResponder.js","../../node_modules/react-native-web/dist/modules/usePressEvents/index.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\nvar getElementRole = element => element.getAttribute('role');\nvar getElementType = element => element.tagName.toLowerCase();\nvar isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\nvar isButtonRole = element => getElementRole(element) === 'button';\nvar isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\nvar isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\nvar isValidKeyPress = event => {\n  var key = event.key,\n    target = event.target;\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  var isButtonish = getElementType(target) === 'button' || isButtonRole(target);\n  return key === 'Enter' || isSpacebar && isButtonish;\n};\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\nvar DEFAULT_PRESS_DELAY_MS = 50;\n\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\nexport default class PressResponder {\n  constructor(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n  configure(config) {\n    this._config = config;\n  }\n\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n  reset() {\n    this._cancelLongPressDelayTimeout();\n    this._cancelPressDelayTimeout();\n    this._cancelPressOutDelayTimeout();\n  }\n\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n    return this._eventHandlers;\n  }\n  _createEventHandlers() {\n    var start = (event, shouldDelay) => {\n      event.persist();\n      this._cancelPressOutDelayTimeout();\n      this._longPressDispatched = false;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n      this._receiveSignal(RESPONDER_GRANT, event);\n      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n    var end = event => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n    var keyupHandler = event => {\n      var onPress = this._config.onPress;\n      var target = event.target;\n      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n        var role = target.getAttribute('role');\n        var elementType = getElementType(target);\n        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';\n        if (onPress != null && !isNativeInteractiveElement) {\n          onPress(event);\n        }\n      }\n    };\n    return {\n      onStartShouldSetResponder: event => {\n        var disabled = this._config.disabled;\n        if (disabled && isButtonRole(event.currentTarget)) {\n          event.stopPropagation();\n        }\n        if (disabled == null) {\n          return true;\n        }\n        return !disabled;\n      },\n      onKeyDown: event => {\n        var disabled = this._config.disabled;\n        var key = event.key,\n          target = event.target;\n        if (!disabled && isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false);\n            // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n            document.addEventListener('keyup', keyupHandler);\n          }\n          var isSpacebarKey = key === ' ' || key === 'Spacebar';\n          var role = getElementRole(target);\n          var isButtonLikeRole = role === 'button' || role === 'menuitem';\n          if (isSpacebarKey && isButtonLikeRole && getElementType(target) !== 'button') {\n            // Prevent spacebar scrolling the window if using non-native button\n            event.preventDefault();\n          }\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: event => start(event),\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n        var touch = getTouchFromResponderEvent(event);\n        if (this._touchActivatePosition != null) {\n          var deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = this._touchActivatePosition.pageY - touch.pageY;\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: event => end(event),\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: event => {\n        var _this$_config = this._config,\n          cancelable = _this$_config.cancelable,\n          disabled = _this$_config.disabled,\n          onLongPress = _this$_config.onLongPress;\n        // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n        if (cancelable == null) {\n          return true;\n        }\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: event => {\n        var _this$_config2 = this._config,\n          disabled = _this$_config2.disabled,\n          onPress = _this$_config2.onPress;\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          event.stopPropagation();\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.altKey === false) {\n            onPress(event);\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: event => {\n        var _this$_config3 = this._config,\n          disabled = _this$_config3.disabled,\n          onLongPress = _this$_config3.onLongPress;\n        if (!disabled) {\n          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n  }\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n  _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n      return;\n    }\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n      this._touchState = nextState;\n    }\n  }\n\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      // Pressable suppression of contextmenu on windows.\n      // On Windows, the contextmenu is displayed after pointerup.\n      // https://github.com/necolas/react-native-web/issues/2296\n      setTimeout(() => {\n        this._isPointerTouch = false;\n      }, 0);\n      this._touchActivatePosition = null;\n      this._cancelLongPressDelayTimeout();\n    }\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress;\n      // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n        _onLongPress = _this$_config4.onLongPress,\n        onPress = _this$_config4.onPress;\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n    this._cancelPressDelayTimeout();\n  }\n  _activate(event) {\n    var _this$_config5 = this._config,\n      onPressChange = _this$_config5.onPressChange,\n      onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n  _deactivate(event) {\n    var _this$_config6 = this._config,\n      onPressChange = _this$_config6.onPressChange,\n      onPressEnd = _this$_config6.onPressEnd;\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n  _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n}\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n    changedTouches = _event$nativeEvent.changedTouches,\n    touches = _event$nativeEvent.touches;\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n  return event.nativeEvent;\n}","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n\n'use strict';\n\nimport PressResponder from './PressResponder';\nimport { useDebugValue, useEffect, useRef } from 'react';\nexport default function usePressEvents(hostRef, config) {\n  var pressResponderRef = useRef(null);\n  if (pressResponderRef.current == null) {\n    pressResponderRef.current = new PressResponder(config);\n  }\n  var pressResponder = pressResponderRef.current;\n\n  // Re-configure to use the current node and configuration.\n  useEffect(() => {\n    pressResponder.configure(config);\n  }, [config, pressResponder]);\n\n  // Reset the `pressResponder` when cleanup needs to occur. This is\n  // a separate effect because we do not want to rest the responder when `config` changes.\n  useEffect(() => {\n    return () => {\n      pressResponder.reset();\n    };\n  }, [pressResponder]);\n  useDebugValue(config);\n  return pressResponder.getEventHandlers();\n}"],"names":["DELAY","ERROR","LONG_PRESS_DETECTED","NOT_RESPONDER","RESPONDER_ACTIVE_LONG_PRESS_START","RESPONDER_ACTIVE_PRESS_START","RESPONDER_INACTIVE_PRESS_START","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","Transitions","getElementRole","element","getElementType","isActiveSignal","signal","isButtonRole","isPressStartSignal","isTerminalSignal","isValidKeyPress","event","key","target","isSpacebar","isButtonish","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_DELAY_MS","PressResponder","config","start","shouldDelay","delayPressStart","normalizeDelay","delayLongPress","end","keyupHandler","onPress","role","elementType","isNativeInteractiveElement","disabled","isSpacebarKey","isButtonLikeRole","touch","getTouchFromResponderEvent","deltaX","deltaY","_this$_config","cancelable","onLongPress","_this$_config2","_this$_config3","prevState","nextState","isPrevActive","isNextActive","_this$_config4","_onLongPress","isPressCanceledByLongPress","_this$_config5","onPressChange","onPressStart","_this$_config6","onPressEnd","delayPressEnd","delay","min","fallback","_event$nativeEvent","changedTouches","touches","usePressEvents","hostRef","pressResponderRef","useRef","pressResponder","useEffect","useDebugValue"],"mappings":"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","x_google_ignoreList":[0,1]}